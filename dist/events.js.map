{"version":3,"sources":["webpack:///events.js","webpack:///webpack/bootstrap c61830b9aeb4cd32708f","webpack:///./source/Events.js","webpack:///./node_modules/jshashtable/jshashtable.js"],"names":["Events","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","is_array","pVar","toString","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_jshashtable","_jshashtable2","obj","default","this","gateway","Hashtable","hashes","once","defaultPriority","value","pLabel","pFunction","_this","priority","arguments","each","aLabel","concat","register","singleHash","Math","random","substring","undefined","put","typeHash","push","pHash","priorityHash","priorityKeys","keys","I","priorityArray","Y","splice","remove","pMessage","sort","a","b","skipType","hashValue","returnValue","indexOf","unregister","eventObject","eventLabel","priorityObject","priority_hashes","console","log","hashObject","hashCode","FUNCTION","String","ex","equals_fixedValueHasEquals","fixedValue","variableValue","equals","equals_fixedValueNoEquals","createKeyValCheck","kvStr","kv","Error","Bucket","hash","firstKey","firstValue","equalityFunction","entries","addEntry","getEqualityFunction","createBucketSearcher","mode","entry","EXISTENCE","ENTRY","ENTRY_INDEX_AND_VALUE","createBucketLister","entryProperty","aggregatedArr","startIndex","len","searchBuckets","buckets","bucket","getBucketForHash","bucketsByHash","hashingFunctionParam","equalityFunctionParam","that","hashingFunction","checkKey","checkValue","bucketEntry","oldValue","getEntryForKey","containsKey","bucketKey","containsValue","clear","isEmpty","createBucketAggregator","bucketFuncName","aggregated","values","bucketIndex","removeEntryForKey","arrayRemoveAt","size","total","callback","putAll","hashtable","conflictCallback","thisValue","hasConflictCallback","clone","Array","arr","idx","itemsAfterDeleted","slice","searchValue","getEntryAndIndexForKey","result","getEntries"],"mappings":"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","file":"events.js","sourcesContent":["var Events =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _jshashtable = __webpack_require__(1);\n\nvar _jshashtable2 = _interopRequireDefault(_jshashtable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction is_array(pVar) {\n    return Object.prototype.toString.call(pVar) == \"[object Array]\";\n}\n\nvar Events = function () {\n    function Events() {\n        _classCallCheck(this, Events);\n\n        this.gateway = new _jshashtable2.default();\n        this.hashes = new _jshashtable2.default();\n        this.once = [];\n\n        this.defaultPriority = 0;\n    }\n\n    /**\n     * Register for a specific Event. A third optional param can be send that represents the priority.\n     *\n     * @param pLabel string\n     * @param pFunction function\n     */\n\n\n    _createClass(Events, [{\n        key: 'register',\n        value: function register(pLabel, pFunction) {\n            var _this = this;\n\n            //priority\n            var priority = this.defaultPriority;\n\n            if (arguments.length > 2) {\n                priority = arguments[2];\n            }\n\n            if (is_array(pLabel)) {\n\n                var hashes = [];\n\n                pLabel.each(function (aLabel) {\n                    hashes = hashes.concat(_this.register(aLabel, pFunction, priority));\n                });\n\n                return hashes;\n            } else {\n\n                //init givent type\n                var singleHash = (Math.random() + 1).toString(36).substring(7);\n\n                if (this.gateway.get(pLabel) == undefined) {\n                    this.gateway.put(pLabel, new _jshashtable2.default());\n                }\n\n                var typeHash = this.gateway.get(pLabel);\n\n                //check priority\n                if (typeHash.get(priority) == undefined) {\n                    typeHash.put(priority, []);\n                }\n\n                var priorityArray = typeHash.get(priority);\n                priorityArray.push(singleHash);\n                this.hashes.put(singleHash, pFunction);\n\n                return singleHash;\n            }\n        }\n\n        /**\n         * Like register, but will be removed after a single execution\n         * \n         * @param pLabel\n         * @param pFunction\n         */\n\n    }, {\n        key: 'register_once',\n        value: function register_once(pLabel, pFunction) {\n\n            this.once.push(this.register(pLabel, pFunction, arguments[2] || this.defaultPriority));\n        }\n\n        /**\n         * Remove callback from event list\n         * \n         * @param pLabel\n         * @param pHash\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'unregister',\n        value: function unregister(pLabel, pHash) {\n\n            if (this.gateway.get(pLabel) != undefined) {\n\n                var priorityHash = this.gateway.get(pLabel);\n                var priorityKeys = priorityHash.keys();\n\n                for (var I = 0; I < priorityKeys.length; I++) {\n\n                    var priorityArray = priorityHash.get(priorityKeys[I]);\n\n                    for (var Y = 0; Y < priorityArray.length; Y++) {\n\n                        if (priorityArray[Y] == pHash) {\n\n                            priorityArray.splice(Y, 1);\n\n                            this.hashes.remove(pHash);\n\n                            return true;\n                        }\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Fire an event. The gateway searches for listeners and processes the callback with the payload\n         *\n         * @param pLabel string\n         * @param pMessage object\n         */\n\n    }, {\n        key: 'fire',\n        value: function fire(pLabel) {\n            var pMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n            if (this.gateway.get(pLabel) != undefined) {\n\n                var priorityHash = this.gateway.get(pLabel);\n                var priorityKeys = priorityHash.keys();\n\n                priorityKeys.sort(function (a, b) {\n                    return b - a;\n                });\n\n                var skipType = false;\n\n                for (var I = 0; I < priorityKeys.length; I++) {\n\n                    var priorityArray = priorityHash.get(priorityKeys[I]);\n\n                    for (var Y = 0; Y < priorityArray.length; Y++) {\n\n                        var hashValue = priorityArray[Y];\n                        var returnValue = this.hashes.get(hashValue)(pMessage);\n\n                        if (this.once.indexOf(hashValue) > -1) {\n                            this.unregister(pLabel, hashValue);\n                        }\n\n                        // if return value is negative, we stop here!\n                        if (!returnValue) {\n                            false && console.log('Return value break (return not true) for event (' + pLabel + ')');\n                            skipType = true;\n                            break;\n                        }\n                    }\n\n                    if (skipType) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Return array of registered events\n         */\n\n    }, {\n        key: 'showEvents',\n        value: function showEvents() {\n\n            this.gateway.each(function (eventObject) {\n\n                var eventLabel = eventObject.key;\n                var priorityList = eventObject.value;\n\n                priorityList.each(function (priorityObject) {\n\n                    var priorityKey = priorityObject.key;\n                    var priority_hashes = priorityObject.value;\n\n                    if (priority_hashes.length > 0) {\n\n                        console.log(eventLabel + '(' + priority_hashes.length + ')');\n\n                        priority_hashes.each(function (hashObject) {\n                            console.log('#' + hashObject);\n                        });\n\n                        console.log('');\n                    }\n                });\n            });\n        }\n    }]);\n\n    return Events;\n}();\n\nmodule.exports = new Events();\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/**\r\n * Copyright 2010 Tim Down.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * jshashtable\r\n *\r\n * jshashtable is a JavaScript implementation of a hash table. It creates a single constructor function called Hashtable\r\n * in the global scope.\r\n *\r\n * Author: Tim Down <tim@timdown.co.uk>\r\n * Version: 2.1\r\n * Build date: 21 March 2010\r\n * Website: http://www.timdown.co.uk/jshashtable\r\n */\r\n\r\nvar Hashtable = (function() {\r\n\tvar FUNCTION = \"function\";\r\n\r\n\tvar arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?\r\n\t\tfunction(arr, idx) {\r\n\t\t\tarr.splice(idx, 1);\r\n\t\t} :\r\n\r\n\t\tfunction(arr, idx) {\r\n\t\t\tvar itemsAfterDeleted, i, len;\r\n\t\t\tif (idx === arr.length - 1) {\r\n\t\t\t\tarr.length = idx;\r\n\t\t\t} else {\r\n\t\t\t\titemsAfterDeleted = arr.slice(idx + 1);\r\n\t\t\t\tarr.length = idx;\r\n\t\t\t\tfor (i = 0, len = itemsAfterDeleted.length; i < len; ++i) {\r\n\t\t\t\t\tarr[idx + i] = itemsAfterDeleted[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\tfunction hashObject(obj) {\r\n\t\tvar hashCode;\r\n\t\tif (typeof obj == \"string\") {\r\n\t\t\treturn obj;\r\n\t\t} else if (typeof obj.hashCode == FUNCTION) {\r\n\t\t\t// Check the hashCode method really has returned a string\r\n\t\t\thashCode = obj.hashCode();\r\n\t\t\treturn (typeof hashCode == \"string\") ? hashCode : hashObject(hashCode);\r\n\t\t} else if (typeof obj.toString == FUNCTION) {\r\n\t\t\treturn obj.toString();\r\n\t\t} else {\r\n\t\t\ttry {\r\n\t\t\t\treturn String(obj);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when\r\n\t\t\t\t// passed to String()\r\n\t\t\t\treturn Object.prototype.toString.call(obj);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction equals_fixedValueHasEquals(fixedValue, variableValue) {\r\n\t\treturn fixedValue.equals(variableValue);\r\n\t}\r\n\r\n\tfunction equals_fixedValueNoEquals(fixedValue, variableValue) {\r\n\t\treturn (typeof variableValue.equals == FUNCTION) ?\r\n\t\t\t   variableValue.equals(fixedValue) : (fixedValue === variableValue);\r\n\t}\r\n\r\n\tfunction createKeyValCheck(kvStr) {\r\n\t\treturn function(kv) {\r\n\t\t\tif (kv === null) {\r\n\t\t\t\tthrow new Error(\"null is not a valid \" + kvStr);\r\n\t\t\t} else if (typeof kv == \"undefined\") {\r\n\t\t\t\tthrow new Error(kvStr + \" must not be undefined\");\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tvar checkKey = createKeyValCheck(\"key\"), checkValue = createKeyValCheck(\"value\");\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\tfunction Bucket(hash, firstKey, firstValue, equalityFunction) {\r\n        this[0] = hash;\r\n\t\tthis.entries = [];\r\n\t\tthis.addEntry(firstKey, firstValue);\r\n\r\n\t\tif (equalityFunction !== null) {\r\n\t\t\tthis.getEqualityFunction = function() {\r\n\t\t\t\treturn equalityFunction;\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tvar EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;\r\n\r\n\tfunction createBucketSearcher(mode) {\r\n\t\treturn function(key) {\r\n\t\t\tvar i = this.entries.length, entry, equals = this.getEqualityFunction(key);\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = this.entries[i];\r\n\t\t\t\tif ( equals(key, entry[0]) ) {\r\n\t\t\t\t\tswitch (mode) {\r\n\t\t\t\t\t\tcase EXISTENCE:\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\tcase ENTRY:\r\n\t\t\t\t\t\t\treturn entry;\r\n\t\t\t\t\t\tcase ENTRY_INDEX_AND_VALUE:\r\n\t\t\t\t\t\t\treturn [ i, entry[1] ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t}\r\n\r\n\tfunction createBucketLister(entryProperty) {\r\n\t\treturn function(aggregatedArr) {\r\n\t\t\tvar startIndex = aggregatedArr.length;\r\n\t\t\tfor (var i = 0, len = this.entries.length; i < len; ++i) {\r\n\t\t\t\taggregatedArr[startIndex + i] = this.entries[i][entryProperty];\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tBucket.prototype = {\r\n\t\tgetEqualityFunction: function(searchValue) {\r\n\t\t\treturn (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;\r\n\t\t},\r\n\r\n\t\tgetEntryForKey: createBucketSearcher(ENTRY),\r\n\r\n\t\tgetEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),\r\n\r\n\t\tremoveEntryForKey: function(key) {\r\n\t\t\tvar result = this.getEntryAndIndexForKey(key);\r\n\t\t\tif (result) {\r\n\t\t\t\tarrayRemoveAt(this.entries, result[0]);\r\n\t\t\t\treturn result[1];\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\taddEntry: function(key, value) {\r\n\t\t\tthis.entries[this.entries.length] = [key, value];\r\n\t\t},\r\n\r\n\t\tkeys: createBucketLister(0),\r\n\r\n\t\tvalues: createBucketLister(1),\r\n\r\n\t\tgetEntries: function(entries) {\r\n\t\t\tvar startIndex = entries.length;\r\n\t\t\tfor (var i = 0, len = this.entries.length; i < len; ++i) {\r\n\t\t\t\t// Clone the entry stored in the bucket before adding to array\r\n\t\t\t\tentries[startIndex + i] = this.entries[i].slice(0);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcontainsKey: createBucketSearcher(EXISTENCE),\r\n\r\n\t\tcontainsValue: function(value) {\r\n\t\t\tvar i = this.entries.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif ( value === this.entries[i][1] ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\t// Supporting functions for searching hashtable buckets\r\n\r\n\tfunction searchBuckets(buckets, hash) {\r\n\t\tvar i = buckets.length, bucket;\r\n\t\twhile (i--) {\r\n\t\t\tbucket = buckets[i];\r\n\t\t\tif (hash === bucket[0]) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfunction getBucketForHash(bucketsByHash, hash) {\r\n\t\tvar bucket = bucketsByHash[hash];\r\n\r\n\t\t// Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype\r\n\t\treturn ( bucket && (bucket instanceof Bucket) ) ? bucket : null;\r\n\t}\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\tfunction Hashtable(hashingFunctionParam, equalityFunctionParam) {\r\n\t\tvar that = this;\r\n\t\tvar buckets = [];\r\n\t\tvar bucketsByHash = {};\r\n\r\n\t\tvar hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;\r\n\t\tvar equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;\r\n\r\n\t\tthis.put = function(key, value) {\r\n\t\t\tcheckKey(key);\r\n\t\t\tcheckValue(value);\r\n\t\t\tvar hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tbucket = getBucketForHash(bucketsByHash, hash);\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Check this bucket to see if it already contains this key\r\n\t\t\t\tbucketEntry = bucket.getEntryForKey(key);\r\n\t\t\t\tif (bucketEntry) {\r\n\t\t\t\t\t// This bucket entry is the current mapping of key to value, so replace old value and we're done.\r\n\t\t\t\t\toldValue = bucketEntry[1];\r\n\t\t\t\t\tbucketEntry[1] = value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// The bucket does not contain an entry for this key, so add one\r\n\t\t\t\t\tbucket.addEntry(key, value);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// No bucket exists for the key, so create one and put our key/value mapping in\r\n\t\t\t\tbucket = new Bucket(hash, key, value, equalityFunction);\r\n\t\t\t\tbuckets[buckets.length] = bucket;\r\n\t\t\t\tbucketsByHash[hash] = bucket;\r\n\t\t\t}\r\n\t\t\treturn oldValue;\r\n\t\t};\r\n\r\n\t\tthis.get = function(key) {\r\n\t\t\tcheckKey(key);\r\n\r\n\t\t\tvar hash = hashingFunction(key);\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, hash);\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Check this bucket to see if it contains this key\r\n\t\t\t\tvar bucketEntry = bucket.getEntryForKey(key);\r\n\t\t\t\tif (bucketEntry) {\r\n\t\t\t\t\t// This bucket entry is the current mapping of key to value, so return the value.\r\n\t\t\t\t\treturn bucketEntry[1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\tthis.containsKey = function(key) {\r\n\t\t\tcheckKey(key);\r\n\t\t\tvar bucketKey = hashingFunction(key);\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, bucketKey);\r\n\r\n\t\t\treturn bucket ? bucket.containsKey(key) : false;\r\n\t\t};\r\n\r\n\t\tthis.containsValue = function(value) {\r\n\t\t\tcheckValue(value);\r\n\t\t\tvar i = buckets.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (buckets[i].containsValue(value)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n\t\tthis.clear = function() {\r\n\t\t\tbuckets.length = 0;\r\n\t\t\tbucketsByHash = {};\r\n\t\t};\r\n\r\n\t\tthis.isEmpty = function() {\r\n\t\t\treturn !buckets.length;\r\n\t\t};\r\n\r\n\t\tvar createBucketAggregator = function(bucketFuncName) {\r\n\t\t\treturn function() {\r\n\t\t\t\tvar aggregated = [], i = buckets.length;\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tbuckets[i][bucketFuncName](aggregated);\r\n\t\t\t\t}\r\n\t\t\t\treturn aggregated;\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\tthis.keys = createBucketAggregator(\"keys\");\r\n\t\tthis.values = createBucketAggregator(\"values\");\r\n\t\tthis.entries = createBucketAggregator(\"getEntries\");\r\n\r\n\t\tthis.remove = function(key) {\r\n\t\t\tcheckKey(key);\r\n\r\n\t\t\tvar hash = hashingFunction(key), bucketIndex, oldValue = null;\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, hash);\r\n\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Remove entry from this bucket for this key\r\n\t\t\t\toldValue = bucket.removeEntryForKey(key);\r\n\t\t\t\tif (oldValue !== null) {\r\n\t\t\t\t\t// Entry was removed, so check if bucket is empty\r\n\t\t\t\t\tif (!bucket.entries.length) {\r\n\t\t\t\t\t\t// Bucket is empty, so remove it from the bucket collections\r\n\t\t\t\t\t\tbucketIndex = searchBuckets(buckets, hash);\r\n\t\t\t\t\t\tarrayRemoveAt(buckets, bucketIndex);\r\n\t\t\t\t\t\tdelete bucketsByHash[hash];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn oldValue;\r\n\t\t};\r\n\r\n\t\tthis.size = function() {\r\n\t\t\tvar total = 0, i = buckets.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\ttotal += buckets[i].entries.length;\r\n\t\t\t}\r\n\t\t\treturn total;\r\n\t\t};\r\n\r\n\t\tthis.each = function(callback) {\r\n\t\t\tvar entries = that.entries(), i = entries.length, entry;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = entries[i];\r\n\t\t\t\tcallback(entry[0], entry[1]);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.putAll = function(hashtable, conflictCallback) {\r\n\t\t\tvar entries = hashtable.entries();\r\n\t\t\tvar entry, key, value, thisValue, i = entries.length;\r\n\t\t\tvar hasConflictCallback = (typeof conflictCallback == FUNCTION);\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = entries[i];\r\n\t\t\t\tkey = entry[0];\r\n\t\t\t\tvalue = entry[1];\r\n\r\n\t\t\t\t// Check for a conflict. The default behaviour is to overwrite the value for an existing key\r\n\t\t\t\tif ( hasConflictCallback && (thisValue = that.get(key)) ) {\r\n\t\t\t\t\tvalue = conflictCallback(key, thisValue, value);\r\n\t\t\t\t}\r\n\t\t\t\tthat.put(key, value);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.clone = function() {\r\n\t\t\tvar clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);\r\n\t\t\tclone.putAll(that);\r\n\t\t\treturn clone;\r\n\t\t};\r\n\t}\r\n\r\n\treturn Hashtable;\r\n})();\r\n\r\nmodule.exports = Hashtable;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// events.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c61830b9aeb4cd32708f","import Hashtable from 'jshashtable';\n\nfunction is_array(pVar) {\n    return (Object.prototype.toString.call(pVar) == \"[object Array]\");\n}\n\nclass Events {\n\n    constructor() {\n\n        this.gateway = new Hashtable();\n        this.hashes = new Hashtable();\n        this.once = [];\n\n        this.defaultPriority = 0;\n\n    }\n\n    /**\n     * Register for a specific Event. A third optional param can be send that represents the priority.\n     *\n     * @param pLabel string\n     * @param pFunction function\n     */\n    register(pLabel, pFunction) {\n\n        //priority\n        let priority = this.defaultPriority;\n\n        if (arguments.length > 2) {\n            priority = arguments[2];\n        }\n\n        if (is_array(pLabel)) {\n\n            let hashes = [];\n\n            pLabel.each((aLabel) => {\n                hashes = hashes.concat(this.register(aLabel, pFunction, priority));\n            });\n\n            return hashes;\n\n        } else {\n\n            //init givent type\n            let singleHash = (Math.random() + 1).toString(36).substring(7);\n\n            if (this.gateway.get(pLabel) == undefined) {\n                this.gateway.put(pLabel, new Hashtable());\n            }\n\n            let typeHash = this.gateway.get(pLabel);\n\n            //check priority\n            if (typeHash.get(priority) == undefined) {\n                typeHash.put(priority, []);\n            }\n\n            let priorityArray = typeHash.get(priority);\n            priorityArray.push(singleHash);\n            this.hashes.put(singleHash, pFunction);\n\n            return singleHash;\n\n        }\n\n    }\n\n    /**\n     * Like register, but will be removed after a single execution\n     * \n     * @param pLabel\n     * @param pFunction\n     */\n    register_once(pLabel, pFunction) {\n\n        this.once.push(this.register(pLabel, pFunction, arguments[2] || this.defaultPriority));\n\n    }\n\n    /**\n     * Remove callback from event list\n     * \n     * @param pLabel\n     * @param pHash\n     * @returns {boolean}\n     */\n    unregister(pLabel, pHash) {\n\n        if (this.gateway.get(pLabel) != undefined) {\n\n            let priorityHash = this.gateway.get(pLabel);\n            let priorityKeys = priorityHash.keys();\n\n            for (let I = 0; I < priorityKeys.length; I++) {\n\n                let priorityArray = priorityHash.get(priorityKeys[I]);\n\n                for (let Y = 0; Y < priorityArray.length; Y++) {\n\n                    if (priorityArray[Y] == pHash) {\n\n                        priorityArray.splice(Y, 1);\n\n                        this.hashes.remove(pHash);\n\n                        return true;\n                    }\n                }\n\n            }\n\n        }\n\n        return false;\n    }\n\n    /**\n     * Fire an event. The gateway searches for listeners and processes the callback with the payload\n     *\n     * @param pLabel string\n     * @param pMessage object\n     */\n    fire(pLabel, pMessage = {}) {\n\n        if (this.gateway.get(pLabel) != undefined) {\n\n            let priorityHash = this.gateway.get(pLabel);\n            let priorityKeys = priorityHash.keys();\n\n            priorityKeys.sort((a, b) => {\n                return b - a\n            });\n\n            let skipType = false;\n\n            for (let I = 0; I < priorityKeys.length; I++) {\n\n                let priorityArray = priorityHash.get(priorityKeys[I]);\n\n                for (let Y = 0; Y < priorityArray.length; Y++) {\n\n                    let hashValue = priorityArray[Y];\n                    let returnValue = this.hashes.get(hashValue)(pMessage);\n\n                    if (this.once.indexOf(hashValue) > -1) {\n                        this.unregister(pLabel, hashValue);\n                    }\n\n                    // if return value is negative, we stop here!\n                    if (!returnValue) {\n                        __DEV__ && console.log('Return value break (return not true) for event (' + pLabel + ')');\n                        skipType = true;\n                        break;\n                    }\n                }\n\n                if (skipType) {\n                    break;\n                }\n\n            }\n\n        }\n\n    }\n\n    /**\n     * Return array of registered events\n     */\n    showEvents() {\n\n        this.gateway.each((eventObject) => {\n\n            let eventLabel = eventObject.key;\n            let priorityList = eventObject.value;\n\n            priorityList.each((priorityObject) => {\n\n                let priorityKey = priorityObject.key;\n                let priority_hashes = priorityObject.value;\n\n                if (priority_hashes.length > 0) {\n\n                    console.log(eventLabel + '(' + priority_hashes.length + ')');\n\n                    priority_hashes.each(function (hashObject) {\n                        console.log('#' + hashObject)\n                    });\n\n                    console.log('');\n\n                }\n            });\n\n        });\n\n    }\n\n}\n\nmodule.exports = new Events();\n\n\n// WEBPACK FOOTER //\n// ./source/Events.js","/**\r\n * Copyright 2010 Tim Down.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * jshashtable\r\n *\r\n * jshashtable is a JavaScript implementation of a hash table. It creates a single constructor function called Hashtable\r\n * in the global scope.\r\n *\r\n * Author: Tim Down <tim@timdown.co.uk>\r\n * Version: 2.1\r\n * Build date: 21 March 2010\r\n * Website: http://www.timdown.co.uk/jshashtable\r\n */\r\n\r\nvar Hashtable = (function() {\r\n\tvar FUNCTION = \"function\";\r\n\r\n\tvar arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?\r\n\t\tfunction(arr, idx) {\r\n\t\t\tarr.splice(idx, 1);\r\n\t\t} :\r\n\r\n\t\tfunction(arr, idx) {\r\n\t\t\tvar itemsAfterDeleted, i, len;\r\n\t\t\tif (idx === arr.length - 1) {\r\n\t\t\t\tarr.length = idx;\r\n\t\t\t} else {\r\n\t\t\t\titemsAfterDeleted = arr.slice(idx + 1);\r\n\t\t\t\tarr.length = idx;\r\n\t\t\t\tfor (i = 0, len = itemsAfterDeleted.length; i < len; ++i) {\r\n\t\t\t\t\tarr[idx + i] = itemsAfterDeleted[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\tfunction hashObject(obj) {\r\n\t\tvar hashCode;\r\n\t\tif (typeof obj == \"string\") {\r\n\t\t\treturn obj;\r\n\t\t} else if (typeof obj.hashCode == FUNCTION) {\r\n\t\t\t// Check the hashCode method really has returned a string\r\n\t\t\thashCode = obj.hashCode();\r\n\t\t\treturn (typeof hashCode == \"string\") ? hashCode : hashObject(hashCode);\r\n\t\t} else if (typeof obj.toString == FUNCTION) {\r\n\t\t\treturn obj.toString();\r\n\t\t} else {\r\n\t\t\ttry {\r\n\t\t\t\treturn String(obj);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when\r\n\t\t\t\t// passed to String()\r\n\t\t\t\treturn Object.prototype.toString.call(obj);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction equals_fixedValueHasEquals(fixedValue, variableValue) {\r\n\t\treturn fixedValue.equals(variableValue);\r\n\t}\r\n\r\n\tfunction equals_fixedValueNoEquals(fixedValue, variableValue) {\r\n\t\treturn (typeof variableValue.equals == FUNCTION) ?\r\n\t\t\t   variableValue.equals(fixedValue) : (fixedValue === variableValue);\r\n\t}\r\n\r\n\tfunction createKeyValCheck(kvStr) {\r\n\t\treturn function(kv) {\r\n\t\t\tif (kv === null) {\r\n\t\t\t\tthrow new Error(\"null is not a valid \" + kvStr);\r\n\t\t\t} else if (typeof kv == \"undefined\") {\r\n\t\t\t\tthrow new Error(kvStr + \" must not be undefined\");\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tvar checkKey = createKeyValCheck(\"key\"), checkValue = createKeyValCheck(\"value\");\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\tfunction Bucket(hash, firstKey, firstValue, equalityFunction) {\r\n        this[0] = hash;\r\n\t\tthis.entries = [];\r\n\t\tthis.addEntry(firstKey, firstValue);\r\n\r\n\t\tif (equalityFunction !== null) {\r\n\t\t\tthis.getEqualityFunction = function() {\r\n\t\t\t\treturn equalityFunction;\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tvar EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;\r\n\r\n\tfunction createBucketSearcher(mode) {\r\n\t\treturn function(key) {\r\n\t\t\tvar i = this.entries.length, entry, equals = this.getEqualityFunction(key);\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = this.entries[i];\r\n\t\t\t\tif ( equals(key, entry[0]) ) {\r\n\t\t\t\t\tswitch (mode) {\r\n\t\t\t\t\t\tcase EXISTENCE:\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\tcase ENTRY:\r\n\t\t\t\t\t\t\treturn entry;\r\n\t\t\t\t\t\tcase ENTRY_INDEX_AND_VALUE:\r\n\t\t\t\t\t\t\treturn [ i, entry[1] ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t}\r\n\r\n\tfunction createBucketLister(entryProperty) {\r\n\t\treturn function(aggregatedArr) {\r\n\t\t\tvar startIndex = aggregatedArr.length;\r\n\t\t\tfor (var i = 0, len = this.entries.length; i < len; ++i) {\r\n\t\t\t\taggregatedArr[startIndex + i] = this.entries[i][entryProperty];\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tBucket.prototype = {\r\n\t\tgetEqualityFunction: function(searchValue) {\r\n\t\t\treturn (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;\r\n\t\t},\r\n\r\n\t\tgetEntryForKey: createBucketSearcher(ENTRY),\r\n\r\n\t\tgetEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),\r\n\r\n\t\tremoveEntryForKey: function(key) {\r\n\t\t\tvar result = this.getEntryAndIndexForKey(key);\r\n\t\t\tif (result) {\r\n\t\t\t\tarrayRemoveAt(this.entries, result[0]);\r\n\t\t\t\treturn result[1];\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\taddEntry: function(key, value) {\r\n\t\t\tthis.entries[this.entries.length] = [key, value];\r\n\t\t},\r\n\r\n\t\tkeys: createBucketLister(0),\r\n\r\n\t\tvalues: createBucketLister(1),\r\n\r\n\t\tgetEntries: function(entries) {\r\n\t\t\tvar startIndex = entries.length;\r\n\t\t\tfor (var i = 0, len = this.entries.length; i < len; ++i) {\r\n\t\t\t\t// Clone the entry stored in the bucket before adding to array\r\n\t\t\t\tentries[startIndex + i] = this.entries[i].slice(0);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcontainsKey: createBucketSearcher(EXISTENCE),\r\n\r\n\t\tcontainsValue: function(value) {\r\n\t\t\tvar i = this.entries.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif ( value === this.entries[i][1] ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\t// Supporting functions for searching hashtable buckets\r\n\r\n\tfunction searchBuckets(buckets, hash) {\r\n\t\tvar i = buckets.length, bucket;\r\n\t\twhile (i--) {\r\n\t\t\tbucket = buckets[i];\r\n\t\t\tif (hash === bucket[0]) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfunction getBucketForHash(bucketsByHash, hash) {\r\n\t\tvar bucket = bucketsByHash[hash];\r\n\r\n\t\t// Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype\r\n\t\treturn ( bucket && (bucket instanceof Bucket) ) ? bucket : null;\r\n\t}\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\tfunction Hashtable(hashingFunctionParam, equalityFunctionParam) {\r\n\t\tvar that = this;\r\n\t\tvar buckets = [];\r\n\t\tvar bucketsByHash = {};\r\n\r\n\t\tvar hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;\r\n\t\tvar equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;\r\n\r\n\t\tthis.put = function(key, value) {\r\n\t\t\tcheckKey(key);\r\n\t\t\tcheckValue(value);\r\n\t\t\tvar hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tbucket = getBucketForHash(bucketsByHash, hash);\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Check this bucket to see if it already contains this key\r\n\t\t\t\tbucketEntry = bucket.getEntryForKey(key);\r\n\t\t\t\tif (bucketEntry) {\r\n\t\t\t\t\t// This bucket entry is the current mapping of key to value, so replace old value and we're done.\r\n\t\t\t\t\toldValue = bucketEntry[1];\r\n\t\t\t\t\tbucketEntry[1] = value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// The bucket does not contain an entry for this key, so add one\r\n\t\t\t\t\tbucket.addEntry(key, value);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// No bucket exists for the key, so create one and put our key/value mapping in\r\n\t\t\t\tbucket = new Bucket(hash, key, value, equalityFunction);\r\n\t\t\t\tbuckets[buckets.length] = bucket;\r\n\t\t\t\tbucketsByHash[hash] = bucket;\r\n\t\t\t}\r\n\t\t\treturn oldValue;\r\n\t\t};\r\n\r\n\t\tthis.get = function(key) {\r\n\t\t\tcheckKey(key);\r\n\r\n\t\t\tvar hash = hashingFunction(key);\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, hash);\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Check this bucket to see if it contains this key\r\n\t\t\t\tvar bucketEntry = bucket.getEntryForKey(key);\r\n\t\t\t\tif (bucketEntry) {\r\n\t\t\t\t\t// This bucket entry is the current mapping of key to value, so return the value.\r\n\t\t\t\t\treturn bucketEntry[1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\tthis.containsKey = function(key) {\r\n\t\t\tcheckKey(key);\r\n\t\t\tvar bucketKey = hashingFunction(key);\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, bucketKey);\r\n\r\n\t\t\treturn bucket ? bucket.containsKey(key) : false;\r\n\t\t};\r\n\r\n\t\tthis.containsValue = function(value) {\r\n\t\t\tcheckValue(value);\r\n\t\t\tvar i = buckets.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (buckets[i].containsValue(value)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n\t\tthis.clear = function() {\r\n\t\t\tbuckets.length = 0;\r\n\t\t\tbucketsByHash = {};\r\n\t\t};\r\n\r\n\t\tthis.isEmpty = function() {\r\n\t\t\treturn !buckets.length;\r\n\t\t};\r\n\r\n\t\tvar createBucketAggregator = function(bucketFuncName) {\r\n\t\t\treturn function() {\r\n\t\t\t\tvar aggregated = [], i = buckets.length;\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tbuckets[i][bucketFuncName](aggregated);\r\n\t\t\t\t}\r\n\t\t\t\treturn aggregated;\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\tthis.keys = createBucketAggregator(\"keys\");\r\n\t\tthis.values = createBucketAggregator(\"values\");\r\n\t\tthis.entries = createBucketAggregator(\"getEntries\");\r\n\r\n\t\tthis.remove = function(key) {\r\n\t\t\tcheckKey(key);\r\n\r\n\t\t\tvar hash = hashingFunction(key), bucketIndex, oldValue = null;\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, hash);\r\n\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Remove entry from this bucket for this key\r\n\t\t\t\toldValue = bucket.removeEntryForKey(key);\r\n\t\t\t\tif (oldValue !== null) {\r\n\t\t\t\t\t// Entry was removed, so check if bucket is empty\r\n\t\t\t\t\tif (!bucket.entries.length) {\r\n\t\t\t\t\t\t// Bucket is empty, so remove it from the bucket collections\r\n\t\t\t\t\t\tbucketIndex = searchBuckets(buckets, hash);\r\n\t\t\t\t\t\tarrayRemoveAt(buckets, bucketIndex);\r\n\t\t\t\t\t\tdelete bucketsByHash[hash];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn oldValue;\r\n\t\t};\r\n\r\n\t\tthis.size = function() {\r\n\t\t\tvar total = 0, i = buckets.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\ttotal += buckets[i].entries.length;\r\n\t\t\t}\r\n\t\t\treturn total;\r\n\t\t};\r\n\r\n\t\tthis.each = function(callback) {\r\n\t\t\tvar entries = that.entries(), i = entries.length, entry;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = entries[i];\r\n\t\t\t\tcallback(entry[0], entry[1]);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.putAll = function(hashtable, conflictCallback) {\r\n\t\t\tvar entries = hashtable.entries();\r\n\t\t\tvar entry, key, value, thisValue, i = entries.length;\r\n\t\t\tvar hasConflictCallback = (typeof conflictCallback == FUNCTION);\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = entries[i];\r\n\t\t\t\tkey = entry[0];\r\n\t\t\t\tvalue = entry[1];\r\n\r\n\t\t\t\t// Check for a conflict. The default behaviour is to overwrite the value for an existing key\r\n\t\t\t\tif ( hasConflictCallback && (thisValue = that.get(key)) ) {\r\n\t\t\t\t\tvalue = conflictCallback(key, thisValue, value);\r\n\t\t\t\t}\r\n\t\t\t\tthat.put(key, value);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.clone = function() {\r\n\t\t\tvar clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);\r\n\t\t\tclone.putAll(that);\r\n\t\t\treturn clone;\r\n\t\t};\r\n\t}\r\n\r\n\treturn Hashtable;\r\n})();\r\n\r\nmodule.exports = Hashtable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jshashtable/jshashtable.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}