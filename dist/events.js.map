{"version":3,"sources":["webpack:///webpack/bootstrap c271ee7638e501245ec5","webpack:///./source/Events.js","webpack:///./node_modules/jshashtable/jshashtable.js"],"names":["is_array","pVar","Object","prototype","toString","call","Events","gateway","Hashtable","hashes","once","defaultPriority","pLabel","pFunction","priority","arguments","length","each","aLabel","concat","register","singleHash","Math","random","substring","get","undefined","put","typeHash","priorityArray","push","pHash","priorityHash","priorityKeys","keys","I","Y","splice","remove","pMessage","sort","a","b","skipType","hashValue","returnValue","indexOf","unregister","__DEV__","console","log","eventObject","eventLabel","key","priorityList","value","priorityObject","priorityKey","priority_hashes","hashObject","module","exports"],"mappings":"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AAE5BiC,gCAAQC,GAAR,CAAYE,aAAa,GAAb,GAAmBM,gBAAgB1C,MAAnC,GAA4C,GAAxD;;AAEA0C,wCAAgBzC,IAAhB,CAAqB,UAAU0C,UAAV,EAAsB;AACvCV,oCAAQC,GAAR,CAAY,MAAMS,UAAlB;AACH,yBAFD;;AAIAV,gCAAQC,GAAR,CAAY,EAAZ;AAEH;AACJ,iBAhBD;AAkBH,aAvBD;AAyBH;;;;;;AAILU,OAAOC,OAAP,GAAiB,IAAIvD,MAAJ,EAAjB,C;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,2B","file":"events.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c271ee7638e501245ec5","import Hashtable from 'jshashtable';\n\nfunction is_array(pVar) {\n    return (Object.prototype.toString.call(pVar) == \"[object Array]\");\n}\n\nclass Events {\n\n    constructor() {\n\n        this.gateway = new Hashtable();\n        this.hashes = new Hashtable();\n        this.once = [];\n\n        this.defaultPriority = 0;\n\n    }\n\n    /**\n     * Register for a specific Event. A third optional param can be send that represents the priority.\n     *\n     * @param pLabel string\n     * @param pFunction function\n     */\n    register(pLabel, pFunction) {\n\n        //priority\n        let priority = this.defaultPriority;\n\n        if (arguments.length > 2) {\n            priority = arguments[2];\n        }\n\n        if (is_array(pLabel)) {\n\n            let hashes = [];\n\n            pLabel.each((aLabel) => {\n                hashes = hashes.concat(this.register(aLabel, pFunction, priority));\n            });\n\n            return hashes;\n\n        } else {\n\n            //init givent type\n            let singleHash = (Math.random() + 1).toString(36).substring(7);\n\n            if (this.gateway.get(pLabel) == undefined) {\n                this.gateway.put(pLabel, new Hashtable());\n            }\n\n            let typeHash = this.gateway.get(pLabel);\n\n            //check priority\n            if (typeHash.get(priority) == undefined) {\n                typeHash.put(priority, []);\n            }\n\n            let priorityArray = typeHash.get(priority);\n            priorityArray.push(singleHash);\n            this.hashes.put(singleHash, pFunction);\n\n            return singleHash;\n\n        }\n\n    }\n\n    /**\n     * Like register, but will be removed after a single execution\n     * \n     * @param pLabel\n     * @param pFunction\n     */\n    register_once(pLabel, pFunction) {\n\n        this.once.push(this.register(pLabel, pFunction, arguments[2] || this.defaultPriority));\n\n    }\n\n    /**\n     * Remove callback from event list\n     * \n     * @param pLabel\n     * @param pHash\n     * @returns {boolean}\n     */\n    unregister(pLabel, pHash) {\n\n        if (this.gateway.get(pLabel) != undefined) {\n\n            let priorityHash = this.gateway.get(pLabel);\n            let priorityKeys = priorityHash.keys();\n\n            for (let I = 0; I < priorityKeys.length; I++) {\n\n                let priorityArray = priorityHash.get(priorityKeys[I]);\n\n                for (let Y = 0; Y < priorityArray.length; Y++) {\n\n                    if (priorityArray[Y] == pHash) {\n\n                        priorityArray.splice(Y, 1);\n\n                        this.hashes.remove(pHash);\n\n                        return true;\n                    }\n                }\n\n            }\n\n        }\n\n        return false;\n    }\n\n    /**\n     * Fire an event. The gateway searches for listeners and processes the callback with the payload\n     *\n     * @param pLabel string\n     * @param pMessage object\n     */\n    fire(pLabel, pMessage = {}) {\n\n        if (this.gateway.get(pLabel) != undefined) {\n\n            let priorityHash = this.gateway.get(pLabel);\n            let priorityKeys = priorityHash.keys();\n\n            priorityKeys.sort((a, b) => {\n                return b - a\n            });\n\n            let skipType = false;\n\n            for (let I = 0; I < priorityKeys.length; I++) {\n\n                let priorityArray = priorityHash.get(priorityKeys[I]);\n\n                for (let Y = 0; Y < priorityArray.length; Y++) {\n\n                    let hashValue = priorityArray[Y];\n\n                    let returnValue = this.hashes.get(hashValue)(pMessage);\n\n                    if (this.once.indexOf(hashValue) > -1) {\n                        this.unregister(pLabel, hashValue);\n                    }\n\n                    if (!returnValue) { // if return value is negative, we stop here!\n\n                        __DEV__ && console.log('Return value break (return not true) for event (' + pLabel + ')');\n\n                        skipType = true;\n                        break;\n                    }\n                }\n\n                if (skipType) {\n                    break;\n                }\n\n            }\n\n        }\n\n    }\n\n    /**\n     * Return array of registered events\n     */\n    showEvents() {\n\n        this.gateway.each((eventObject) => {\n\n            let eventLabel = eventObject.key;\n            let priorityList = eventObject.value;\n\n            priorityList.each((priorityObject) => {\n\n                let priorityKey = priorityObject.key;\n                let priority_hashes = priorityObject.value;\n\n                if (priority_hashes.length > 0) {\n\n                    console.log(eventLabel + '(' + priority_hashes.length + ')');\n\n                    priority_hashes.each(function (hashObject) {\n                        console.log('#' + hashObject)\n                    });\n\n                    console.log('');\n\n                }\n            });\n\n        });\n\n    }\n\n}\n\nmodule.exports = new Events();\n\n\n// WEBPACK FOOTER //\n// ./source/Events.js","/**\r\n * Copyright 2010 Tim Down.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * jshashtable\r\n *\r\n * jshashtable is a JavaScript implementation of a hash table. It creates a single constructor function called Hashtable\r\n * in the global scope.\r\n *\r\n * Author: Tim Down <tim@timdown.co.uk>\r\n * Version: 2.1\r\n * Build date: 21 March 2010\r\n * Website: http://www.timdown.co.uk/jshashtable\r\n */\r\n\r\nvar Hashtable = (function() {\r\n\tvar FUNCTION = \"function\";\r\n\r\n\tvar arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?\r\n\t\tfunction(arr, idx) {\r\n\t\t\tarr.splice(idx, 1);\r\n\t\t} :\r\n\r\n\t\tfunction(arr, idx) {\r\n\t\t\tvar itemsAfterDeleted, i, len;\r\n\t\t\tif (idx === arr.length - 1) {\r\n\t\t\t\tarr.length = idx;\r\n\t\t\t} else {\r\n\t\t\t\titemsAfterDeleted = arr.slice(idx + 1);\r\n\t\t\t\tarr.length = idx;\r\n\t\t\t\tfor (i = 0, len = itemsAfterDeleted.length; i < len; ++i) {\r\n\t\t\t\t\tarr[idx + i] = itemsAfterDeleted[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\tfunction hashObject(obj) {\r\n\t\tvar hashCode;\r\n\t\tif (typeof obj == \"string\") {\r\n\t\t\treturn obj;\r\n\t\t} else if (typeof obj.hashCode == FUNCTION) {\r\n\t\t\t// Check the hashCode method really has returned a string\r\n\t\t\thashCode = obj.hashCode();\r\n\t\t\treturn (typeof hashCode == \"string\") ? hashCode : hashObject(hashCode);\r\n\t\t} else if (typeof obj.toString == FUNCTION) {\r\n\t\t\treturn obj.toString();\r\n\t\t} else {\r\n\t\t\ttry {\r\n\t\t\t\treturn String(obj);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\t// For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when\r\n\t\t\t\t// passed to String()\r\n\t\t\t\treturn Object.prototype.toString.call(obj);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction equals_fixedValueHasEquals(fixedValue, variableValue) {\r\n\t\treturn fixedValue.equals(variableValue);\r\n\t}\r\n\r\n\tfunction equals_fixedValueNoEquals(fixedValue, variableValue) {\r\n\t\treturn (typeof variableValue.equals == FUNCTION) ?\r\n\t\t\t   variableValue.equals(fixedValue) : (fixedValue === variableValue);\r\n\t}\r\n\r\n\tfunction createKeyValCheck(kvStr) {\r\n\t\treturn function(kv) {\r\n\t\t\tif (kv === null) {\r\n\t\t\t\tthrow new Error(\"null is not a valid \" + kvStr);\r\n\t\t\t} else if (typeof kv == \"undefined\") {\r\n\t\t\t\tthrow new Error(kvStr + \" must not be undefined\");\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tvar checkKey = createKeyValCheck(\"key\"), checkValue = createKeyValCheck(\"value\");\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\tfunction Bucket(hash, firstKey, firstValue, equalityFunction) {\r\n        this[0] = hash;\r\n\t\tthis.entries = [];\r\n\t\tthis.addEntry(firstKey, firstValue);\r\n\r\n\t\tif (equalityFunction !== null) {\r\n\t\t\tthis.getEqualityFunction = function() {\r\n\t\t\t\treturn equalityFunction;\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tvar EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;\r\n\r\n\tfunction createBucketSearcher(mode) {\r\n\t\treturn function(key) {\r\n\t\t\tvar i = this.entries.length, entry, equals = this.getEqualityFunction(key);\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = this.entries[i];\r\n\t\t\t\tif ( equals(key, entry[0]) ) {\r\n\t\t\t\t\tswitch (mode) {\r\n\t\t\t\t\t\tcase EXISTENCE:\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\tcase ENTRY:\r\n\t\t\t\t\t\t\treturn entry;\r\n\t\t\t\t\t\tcase ENTRY_INDEX_AND_VALUE:\r\n\t\t\t\t\t\t\treturn [ i, entry[1] ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t}\r\n\r\n\tfunction createBucketLister(entryProperty) {\r\n\t\treturn function(aggregatedArr) {\r\n\t\t\tvar startIndex = aggregatedArr.length;\r\n\t\t\tfor (var i = 0, len = this.entries.length; i < len; ++i) {\r\n\t\t\t\taggregatedArr[startIndex + i] = this.entries[i][entryProperty];\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tBucket.prototype = {\r\n\t\tgetEqualityFunction: function(searchValue) {\r\n\t\t\treturn (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;\r\n\t\t},\r\n\r\n\t\tgetEntryForKey: createBucketSearcher(ENTRY),\r\n\r\n\t\tgetEntryAndIndexForKey: createBucketSearcher(ENTRY_INDEX_AND_VALUE),\r\n\r\n\t\tremoveEntryForKey: function(key) {\r\n\t\t\tvar result = this.getEntryAndIndexForKey(key);\r\n\t\t\tif (result) {\r\n\t\t\t\tarrayRemoveAt(this.entries, result[0]);\r\n\t\t\t\treturn result[1];\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\taddEntry: function(key, value) {\r\n\t\t\tthis.entries[this.entries.length] = [key, value];\r\n\t\t},\r\n\r\n\t\tkeys: createBucketLister(0),\r\n\r\n\t\tvalues: createBucketLister(1),\r\n\r\n\t\tgetEntries: function(entries) {\r\n\t\t\tvar startIndex = entries.length;\r\n\t\t\tfor (var i = 0, len = this.entries.length; i < len; ++i) {\r\n\t\t\t\t// Clone the entry stored in the bucket before adding to array\r\n\t\t\t\tentries[startIndex + i] = this.entries[i].slice(0);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcontainsKey: createBucketSearcher(EXISTENCE),\r\n\r\n\t\tcontainsValue: function(value) {\r\n\t\t\tvar i = this.entries.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif ( value === this.entries[i][1] ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\t// Supporting functions for searching hashtable buckets\r\n\r\n\tfunction searchBuckets(buckets, hash) {\r\n\t\tvar i = buckets.length, bucket;\r\n\t\twhile (i--) {\r\n\t\t\tbucket = buckets[i];\r\n\t\t\tif (hash === bucket[0]) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfunction getBucketForHash(bucketsByHash, hash) {\r\n\t\tvar bucket = bucketsByHash[hash];\r\n\r\n\t\t// Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype\r\n\t\treturn ( bucket && (bucket instanceof Bucket) ) ? bucket : null;\r\n\t}\r\n\r\n\t/*----------------------------------------------------------------------------------------------------------------*/\r\n\r\n\tfunction Hashtable(hashingFunctionParam, equalityFunctionParam) {\r\n\t\tvar that = this;\r\n\t\tvar buckets = [];\r\n\t\tvar bucketsByHash = {};\r\n\r\n\t\tvar hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;\r\n\t\tvar equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;\r\n\r\n\t\tthis.put = function(key, value) {\r\n\t\t\tcheckKey(key);\r\n\t\t\tcheckValue(value);\r\n\t\t\tvar hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tbucket = getBucketForHash(bucketsByHash, hash);\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Check this bucket to see if it already contains this key\r\n\t\t\t\tbucketEntry = bucket.getEntryForKey(key);\r\n\t\t\t\tif (bucketEntry) {\r\n\t\t\t\t\t// This bucket entry is the current mapping of key to value, so replace old value and we're done.\r\n\t\t\t\t\toldValue = bucketEntry[1];\r\n\t\t\t\t\tbucketEntry[1] = value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// The bucket does not contain an entry for this key, so add one\r\n\t\t\t\t\tbucket.addEntry(key, value);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// No bucket exists for the key, so create one and put our key/value mapping in\r\n\t\t\t\tbucket = new Bucket(hash, key, value, equalityFunction);\r\n\t\t\t\tbuckets[buckets.length] = bucket;\r\n\t\t\t\tbucketsByHash[hash] = bucket;\r\n\t\t\t}\r\n\t\t\treturn oldValue;\r\n\t\t};\r\n\r\n\t\tthis.get = function(key) {\r\n\t\t\tcheckKey(key);\r\n\r\n\t\t\tvar hash = hashingFunction(key);\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, hash);\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Check this bucket to see if it contains this key\r\n\t\t\t\tvar bucketEntry = bucket.getEntryForKey(key);\r\n\t\t\t\tif (bucketEntry) {\r\n\t\t\t\t\t// This bucket entry is the current mapping of key to value, so return the value.\r\n\t\t\t\t\treturn bucketEntry[1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\tthis.containsKey = function(key) {\r\n\t\t\tcheckKey(key);\r\n\t\t\tvar bucketKey = hashingFunction(key);\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, bucketKey);\r\n\r\n\t\t\treturn bucket ? bucket.containsKey(key) : false;\r\n\t\t};\r\n\r\n\t\tthis.containsValue = function(value) {\r\n\t\t\tcheckValue(value);\r\n\t\t\tvar i = buckets.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (buckets[i].containsValue(value)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n\t\tthis.clear = function() {\r\n\t\t\tbuckets.length = 0;\r\n\t\t\tbucketsByHash = {};\r\n\t\t};\r\n\r\n\t\tthis.isEmpty = function() {\r\n\t\t\treturn !buckets.length;\r\n\t\t};\r\n\r\n\t\tvar createBucketAggregator = function(bucketFuncName) {\r\n\t\t\treturn function() {\r\n\t\t\t\tvar aggregated = [], i = buckets.length;\r\n\t\t\t\twhile (i--) {\r\n\t\t\t\t\tbuckets[i][bucketFuncName](aggregated);\r\n\t\t\t\t}\r\n\t\t\t\treturn aggregated;\r\n\t\t\t};\r\n\t\t};\r\n\r\n\t\tthis.keys = createBucketAggregator(\"keys\");\r\n\t\tthis.values = createBucketAggregator(\"values\");\r\n\t\tthis.entries = createBucketAggregator(\"getEntries\");\r\n\r\n\t\tthis.remove = function(key) {\r\n\t\t\tcheckKey(key);\r\n\r\n\t\t\tvar hash = hashingFunction(key), bucketIndex, oldValue = null;\r\n\r\n\t\t\t// Check if a bucket exists for the bucket key\r\n\t\t\tvar bucket = getBucketForHash(bucketsByHash, hash);\r\n\r\n\t\t\tif (bucket) {\r\n\t\t\t\t// Remove entry from this bucket for this key\r\n\t\t\t\toldValue = bucket.removeEntryForKey(key);\r\n\t\t\t\tif (oldValue !== null) {\r\n\t\t\t\t\t// Entry was removed, so check if bucket is empty\r\n\t\t\t\t\tif (!bucket.entries.length) {\r\n\t\t\t\t\t\t// Bucket is empty, so remove it from the bucket collections\r\n\t\t\t\t\t\tbucketIndex = searchBuckets(buckets, hash);\r\n\t\t\t\t\t\tarrayRemoveAt(buckets, bucketIndex);\r\n\t\t\t\t\t\tdelete bucketsByHash[hash];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn oldValue;\r\n\t\t};\r\n\r\n\t\tthis.size = function() {\r\n\t\t\tvar total = 0, i = buckets.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\ttotal += buckets[i].entries.length;\r\n\t\t\t}\r\n\t\t\treturn total;\r\n\t\t};\r\n\r\n\t\tthis.each = function(callback) {\r\n\t\t\tvar entries = that.entries(), i = entries.length, entry;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = entries[i];\r\n\t\t\t\tcallback(entry[0], entry[1]);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.putAll = function(hashtable, conflictCallback) {\r\n\t\t\tvar entries = hashtable.entries();\r\n\t\t\tvar entry, key, value, thisValue, i = entries.length;\r\n\t\t\tvar hasConflictCallback = (typeof conflictCallback == FUNCTION);\r\n\t\t\twhile (i--) {\r\n\t\t\t\tentry = entries[i];\r\n\t\t\t\tkey = entry[0];\r\n\t\t\t\tvalue = entry[1];\r\n\r\n\t\t\t\t// Check for a conflict. The default behaviour is to overwrite the value for an existing key\r\n\t\t\t\tif ( hasConflictCallback && (thisValue = that.get(key)) ) {\r\n\t\t\t\t\tvalue = conflictCallback(key, thisValue, value);\r\n\t\t\t\t}\r\n\t\t\t\tthat.put(key, value);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.clone = function() {\r\n\t\t\tvar clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);\r\n\t\t\tclone.putAll(that);\r\n\t\t\treturn clone;\r\n\t\t};\r\n\t}\r\n\r\n\treturn Hashtable;\r\n})();\r\n\r\nmodule.exports = Hashtable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jshashtable/jshashtable.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}